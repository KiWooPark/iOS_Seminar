### 다이나믹 프로그래밍이란?
```
동적 계획법이라고도 하며,  큰 문제를 작게 나누고, 같은 문제라면 한번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.
```

### 다이나믹 프로그래밍 구현 방법
```
1. 작은 문제들을 한번만 푼다.
2. 정답을 구한 문제의 답을 어딘가에 메모한다.
3. 다시 그 문제가 나오면 앞서 메모한 작은 문제의 결과값을 이용한다.
```

### 다이나믹 프로그래밍을 사용하기 위한 조건
```
1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
위 두 조건이 만족해야 동적 프로그래밍을 사용할 수 있다.
피보나치 수열은 이러한 조건을 만족하는 가장 대표적인 문제이다. 
```

### 다이나믹 프로그래밍과 분할 정복의 차이 
```
가장 큰 차이점은 작은 문제가 중복되는지 안되는지이다.
분할정복은 큰 문제를 해결하기 어려워 작은 문제로만 단순하게 나누어 푸는 방법이고, 다이나믹 프로그래밍은 작은 문제들이 반복되는 것이다. 
```

### 시간 복잡도 
```
다이나믹 프로그래밍의 시간 복잡도는 O(N)이다.
왜냐하면 f(1)을 구한 값이 f(2)를 푸는데 사용되고 f(2) 값이 f(3)을 푸는데 사용되기 때문이다.
```

### 메모제이션이란?
```
다이나믹 프로그래밍을 구현하는 방법 중 한 종류로
한번 구한 결과를 메모리 공간에 메모해두고 같은 문제를 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미한다.
메모제이션은 값을 저장하는 방법이므로 캐싱이라고도 한다.
```

### 메모제이션 구현 방법
```
1. 단순하게 한번 구한 답을 배열에 저장한다.
2. 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 답이 필요할 때는 이미 구한 답을 배열에서 가져와 사용한다.
```

### 탑다운 방식
```
재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법
하향식이라고도 하며 메모제이션 기법은 탑다운 방식에 국한되어 사용되는 기법이다.
```
```swift
let n = 6
var memoizationArr = Array(repeating: 0, count: n + 1)

func fibo(x: Int) -> Int {

    if x == 1 || x == 2 {
        return 1
    }
    
    if memoizationArr[x] != 0 {
        return memoizationArr[x]
    }

    memoizationArr[x] = fibo(x: x - 1) + fibo(x: x - 2)

    return memoizationArr[x]
}

print(fibo(x: n)) // 8
```

### 바텀업 방식
```
단순히 반복문을 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법
상향식이라고도 하며 다이나믹 프로그래밍의 전형적인 형태이다.
```
```swift
let n = 6
var dpTable = Array(repeating: 0, count: n + 1)

dpTable[1] = 1
dpTable[2] = 1

for i in 3..<dpTable.count {
    dpTable[i] = dpTable[i - 1] + dpTable[i - 2]
}

print(dpTable.last!) // 8
```

*****
### 문제 풀이
#### 1로 만들기

```swift
//input
var n = 26

// 입력조건 최대값 30000 + 1 크기의 dp테이블 선언
var dp = Array(repeating: 0, count: 30000 + 1)

// 시작을 2로 하는 이유는
// 1을 만들어야 하기 때문에 0과 1은 계산 X
for i in 2..<n+1 {
    
    dp[i] = dp[i - 1] + 1
    
    if i % 2 == 0 {
        dp[i] = min(dp[i], dp[i / 2] + 1)
    }
    if i % 3 == 0 {
        dp[i] = min(dp[i], dp[i / 3] + 1)
    }
    if i % 5 == 0 {
        dp[i] = min(dp[i], dp[i / 5] + 1)
    }
}

print(dp[n]) // 3

/*
 i 1을 빼는 경우
 2      1
 3      2
 4      3
 5      4
 6      5
 dp[i] = d[[i - 1] + 1 // 1을 빼준 경우 1회 +1
 
 i 2로 나눠질 경우
 2      1
 3
 4      2
 5
 6      3
 dp[i] = d[[i / 2] + 1 // 2로 나눈 경우 1회 +1
 
 i 3으로 나눠질 경우
 2
 3      1
 4
 5
 6      2
 dp[i] = d[[i / 3] + 1 // 3으로 나눈 경우 1회 +1
 
 i 5로 나눠질 경우
 2
 3
 4
 5      1
 6
 dp[i] = d[[i / 5] + 1 // 5로 나눈 경우 1회 +1
 
 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 n = 6 일때
 
 idx = |0|1|2|3|4|5|6|
 dp  = |0|0|0|0|0|0|0|
 
 i = 2
 1을 빼는 경우 -> dp[i-1] + 1 = 1
 2로 나눠지는 경우 -> dp[i/2] + 1 = 1
 둘중 작은 경우 1
 idx = |0|1|2|3|4|5|6|
 dp  = |0|0|1|0|0|0|0|
 
 i = 3
 1을 빼는 경우 -> dp[i-1] + 1 = 2
 3으로 나눠지는 경우 -> dp[i/3] + 1 = 1
 둘중 작은 경우 1
 idx = |0|1|2|3|4|5|6|
 dp  = |0|0|1|1|0|0|0|
 
 i = 4
 1을 빼는 경우 -> dp[i-1] + 1 = 2
 2로 나눠지는 경우 -> dp[i/2] + 1 = 2
 둘중 작은 경우 2
 idx = |0|1|2|3|4|5|6|
 dp  = |0|0|1|1|2|0|0|
 
 i = 5
 1을 빼는 경우 -> dp[i-1] + 1 = 3
 5로 나눠지는 경우 -> dp[i/5] + 1 = 1
 둘중 작은 경우 1
 idx = |0|1|2|3|4|5|6|
 dp  = |0|0|1|1|2|1|0|
 
 i = 6
 1을 빼는 경우 -> dp[i-1] + 1 = 2
 2로 나눠지는 경우 -> dp[i/2] + 1 = 2
 3으로 나눠지는 경우 -> dp[i/3] + 1 = 2
 둘중 작은 경우 2
 idx = |0|1|2|3|4|5|6|
 dp  = |0|0|1|1|2|1|2|
*/
```

#### 개미 전사
```swift
let n = 4
let k = [1,3,1,5]

var dp = Array(repeating: 0, count: 100)

// dp[0] 위치에 1 추가
dp[0] = k[0]

// dp[1] 위치에 입력받은 k배열의 0,1위치값중 큰 값 추가
dp[1] = max(k[0],k[1])

for i in 2..<n {
    dp[i] = max(dp[i-1], dp[i-2] + k[i])
}

print(dp[n-1]) // 8

/*
 최적의 해를 구해보면
 창고 => k = |1|3|1|5|
 
 창고가 1개일때 -> 1
 창고가 2개일때 -> 3
 창고가 3개일때 -> 3
 창고가 4개일때 -> 8
 
 최소한 한칸 이상 떨어진 식량창고를 약탈해야하기 때문에 점화식을 구해보면
 현재위치의 -1의 위치의 값, 현재위치의 -2의 위치의 값 + 현재위치 값으로 2가지 경우를 가지고 비교해볼수 있다.
 # dp[i-1], (dp[i-2] + k[i])
 
 k = |1|3|1|5|
 위 배열에서 2가지 경우를 계산 하려면 2번째 위치에서부터 시작해야하며
 
 i = 2
 |0|1|2|3|
 |1|3|1|5|
 dp[i-1] => 3
 dp[i-2] + k[i] => 1 + 1 = 2
 둘중 큰 식량 개수 3
 dp[i] = 3
 
 i = 3
 |0|1|2|3|
 |1|3|1|5|
 dp[i-1] => 1
 dp[i-2] + k[i] => 3 + 5 = 8
 둘중 큰 식량 개수 8
 dp[i] = 8
 */
```

#### 바닥 공사
```swift
let n = 3

var dp = Array(repeating: 0, count: 1000 + 1)

// n = 1일때 경우의 수
dp[1] = 1
// n = 2일때 경우의 수
dp[2] = 3

for i in 3..<n+1 {
    dp[i] = (dp[i-1] + dp[i-2] * 2) % 796796
}

print(dp[n]) // 5

/*
 # 가로 n , 세로 2 #
 
 덮개의 종류 3가지로 바닥의 가로N이 아래와 같을때 채울수 있는 경우의 수는
 n = 1 일때 경우의 수 => 1
 n = 2 일때 경우의 수 => 3
 n = 3 일때 경우의 수 => 5
 
 덮개중 제일 큰 사이즈가 2x2이기 때문에 N - 2 미만의 길이에 대해서는 고려할 필요 없음
 
 점화식을 구해보면
 i-1 길이까지 덮개가 채워져 있을때 남은 바닥을 채울수 있는 경우의 수는 2x1 사이즈의 덮개 하나밖에 없으므로 경우의 수가 1개가 된다.
 i-2 길이까지 덮개가 채워져 있을때 남은 바닥을 채울수 있는 경우의 수는 1x2 사이즈의 덮개 2개, 2x2 사이즈의 덮개 1개로 경우의 수가 2개가 된다.
 
 dp[i] = dp[i-1] + dp[i-2] * 2
 
 i = 3
 dp[i-1] => 3
 dp[i-2] => 1
 
 dp[i-2] * 2 => 2
 
 최종적으로는 3가지 경우 + 2가지 경우 = 5
 */
```

#### 효율적인 화폐 구성
```swift
let n = 3 // 화폐 개수
let m = 7 // 만들어야 하는 금액

let k = [2,3,5]

// 계산하지 못하는 경우를 10001로 초기화해줌
var dp = Array(repeating: 10001, count: m+1)
// 0원인경우는 화폐를 사용하지 않았을때 만들수 있으므로 0으로 초기화
dp[0] = 0

// 화폐단위 개수만큼 반복
for i in 0..<k.count {
    // 화폐단위부터 dp배열 끝까지 반복
    for j in k[i]..<dp.count {
        
        // 맨처음 실행했을때를 보면
        // j = 2
        // k = 2
        // dp[0] 위치의 값이 10001이 아니기때문에
        // 현재 위치의 값과, dp[0] 위치의 값중에 작은값을 현재 위치에 넣어준다.
        // dp[j - k[i]]의 값이 더 작다면 + 1을 해준다.
        if dp[j - k[i]] != 10001 {
            dp[j] = min(dp[j], dp[j - k[i]] + 1)
        }
    }
}

if dp[m] == 10001 {
    print(-1)
} else {
    print(dp[m]) // 2
}


/*
 만들어야 하는 금액 = m
 m = 7
 
 각각의 화폐 = k
 k = 2, k = 3, k = 5
 
 0원부터 만들어야 하는 금액(m)까지 = i
 i = 0
 i = 1
 i = 2
 i = 3
 i = 4
 i = 5
 i = 6
 i = 7
 
 위 데이터로 점화식을 만들면
 점화식 = a(i - k)
 i = 0부터 m까지 각각의 요소
 k = 각각의 화폐 요소
 
 위 점화식으로 최소한의 화폐 개수를 구할수 있다.
 
 dp[dp[j] - k[i]]
 
 최소한의 화폐 개수를 구해야 하므로 i의 화폐 개수와 i-k + 1의 화폐 개수를 비교해 작은 화폐개수를 고른다.
 */
```

